---
layout: docpage
menu0: userguide
menu1: mdd
---

<div class=lz-r-content>
    <h3>Stacks Directive</h3>
    <p>It is common practice to have different instances of an application stack to support Development, Test and 
        Production stacks. The configuration of each of these application stack instances vary so LazyStack 
        allows you to define stacks with unique configurations. LazyStack requires at least one Stack 
        Definition called "Dev". LazyStack following example defines additional stacks Test and Prod.
    </p>
<pre><code class="language-yaml"># LazyStack Version 1.0.0
Stacks:
  Dev:
    ProfileName: default
    RegionName: us-east-1 
    StackName: PetStoreDev
    UriCodeTarget: Debug/netcoreapp3.1

  Test:
    ProfileName: default
    RegionName: us-east-1 
    StackName: PetStoreTest
    UriCodeTarget: Debug/netcoreapp3.1

  Prod:
    ProfileName: minordiety
    RegionName: us-east-1 
    StackName: PetStoreProd 
    UriCodeTarget: Release/netcoreapp3.1</us-east-1></code></pre>
    <p><i>Note forward slash in UriCodeTarget property values.</i></p>

    <h4>Stacks Directive Properties</h4>
    <ul>
        <li><strong>ProfileName</strong>
          <p> ProfileName is the AWS profile that contains your credentials for accessing an AWS account 
            with a specific role. Usually, the default profile and production profile ("minordiety" in this example) don't 
            reference the same AWS Account. We recommend that each developer to have their own separate AWS 
            development account. In most SDLC flows the developer might not have access to a production account.</p>
            <p> The ProfileName "default" is created for you when you install the AWS CLI. You may have 
            multiple profiles where each profile allows you access to different AWS accounts or different access 
            privileges in an account. We strongly recommend that you do not use your development account to host 
            production stacks. Create a separate account for production and use a production profile to access it. 
            Updating a production stack with a development stack by mistake is not a happy time.</p>
        </li>
        <li><strong>RegionName</strong>
          <p> RegionName is the AWS region your stack is deployed to.</p>   

        </li>
        <li><strong>StackName</strong>
          <p>StackName is the the AWS logical stack name. The LazyStack convention used to name stacks is 
            to append the stack name to the application name. In this example the application name is "PetStore" and 
            the Stack is "Dev" so the StackName is "PetStoreDev".</p>
            
        </li>
        <li><strong>UriCodeTarget</strong>
          <p> UriCodeTarget is the build target to use. Usually one of: Debug/netcoreapp3.1 or Release/netcoreapp3.1</p>
        </li>
    </ul>
    
    <h4>How Stack Environments are used</h4>
    <p>When you run Generate Projects, a Stacks directory is created in your Solution Project's root directory. Then
      a sub-directory for each environment is created under that and an serverless.template file is placed into 
    that sub-directory. These serverless.template files contain the necessary information to publish an application 
    stack to AWS for that environment. For example, the Stacks Directive shown above would produce the following
     directory structure. </p>
     <pre><code class="language-powershell">
PetStore
  Stacks
    Dev 
      serverless.template 
    Prod 
      serverless.template 
    Test 
      serverless.template
     </code></pre>
<i>Note: After you publish a stack you will also use Generate Settings to generate an AwsSettings.json file 
  in the associated Stacks Environment folder. AwsSettings.json files contain the connection information necessary 
  for client applications to call the stack.
</i>
<p></p>
</div>